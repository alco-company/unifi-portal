# FreeRADIUS configuration for Heimdall integration via REST API
# This uses the rest module instead of SQL module for authentication

# Basic server configuration
prefix = /etc/freeradius
exec_prefix = ${prefix}
sysconfdir = ${prefix}
localstatedir = /var
sbindir = ${exec_prefix}/sbin
logdir = /var/log/radius
raddbdir = ${sysconfdir}/freeradius
radacctdir = ${logdir}/radacct

# Process and security
name = freeradius
confdir = ${raddbdir}
run_dir = /var/run/freeradius
db_dir = /var/lib/freeradius
libdir = /usr/lib/freeradius
pidfile = ${run_dir}/${name}.pid
user = nobody
group = nobody
max_request_time = 30
cleanup_delay = 5
max_requests = 16384

# Logging
log {
    destination = stdout
    colourise = yes
    file = ${logdir}/radius.log
    syslog_facility = daemon
    stripped_names = no
    auth = yes
    auth_badpass = yes 
    auth_goodpass = yes
    msg_denied = "You are already logged in - access denied"
}

# Security
security {
    allow_core_dumps = no
    max_attributes = 200
    reject_delay = 1
    status_server = yes
}

# Load necessary modules
$INCLUDE mods-enabled/

# Instantiate modules
instantiate {
    exec
    expr
    expiration
    logintime
    pap
    chap
    mschap
    digest
    unix
    files
    detail
    radutmp
    attr_filter.post-proxy
    attr_filter.pre-proxy
    attr_filter.access_reject
    attr_filter.access_challenge
    attr_filter.accounting_response
    eap
    rest
}

# Define policies
$INCLUDE policy.d/

# Virtual server for Heimdall authentication
server heimdall {
    listen {
        type = auth
        ipaddr = *
        port = 1812
        limit {
            max_connections = 16
            lifetime = 0
            idle_timeout = 30
        }
    }

    listen {
        type = acct
        ipaddr = *
        port = 1813
        limit {
            max_connections = 16
            lifetime = 0
            idle_timeout = 30
        }
    }

    authorize {
        # Log the incoming request
        update control {
            Module-Success-Message = "Processing request for %{User-Name}"
        }

        # Check if this is a known NAS
        if (!ok) {
            update control {
                Auth-Type := Reject
            }
            reject
        }

        # Call Heimdall's authorize endpoint
        rest.authorize

        if (updated) {
            # Authorization successful
            ok
        } else {
            # Authorization failed
            update control {
                Auth-Type := Reject
            }
            reject
        }
    }

    authenticate {
        Auth-Type PAP {
            # Use REST module to authenticate via Heimdall API
            rest.authenticate
        }

        Auth-Type CHAP {
            # CHAP authentication would require password hashes
            # For now, reject CHAP requests
            reject
        }

        Auth-Type MS-CHAP {
            # MS-CHAP authentication would require password hashes  
            # For now, reject MS-CHAP requests
            reject
        }
    }

    preacct {
        preprocess
        acct_unique
        suffix
        files
    }

    accounting {
        # Send accounting to Heimdall
        rest.accounting

        # Also log to detail file for debugging
        detail
        radutmp
        exec
    }

    session {
        radutmp
    }

    post-auth {
        # Update last authentication time in Heimdall
        if (ok || updated) {
            rest.post-auth
        }

        Post-Auth-Type REJECT {
            # Log failed attempts to Heimdall
            rest.post-auth
            
            # Add generic reject message
            update reply {
                Reply-Message = "Authentication rejected"
            }
        }
    }

    pre-proxy {
        attr_filter.pre-proxy
    }

    post-proxy {
        attr_filter.post-proxy
    }
}

# Default virtual server (can be minimal since we use heimdall server)
server default {
    listen {
        type = auth
        ipaddr = *
        port = 0
    }

    authorize {
        reject
    }
}
